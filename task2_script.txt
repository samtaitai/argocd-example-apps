Hello, this is the video for task 2, 'Cluster Management with Argo CD'. 

The first demo is about bootstrapping Argo CD. Since I installed everything for later tasks, let me tell you what I've done so far instead. First, I ran the Docker engine. I skipped the minikube installation part because it was already installed from a previous lab. Next, I started minikube so that I could install Argo CD using kubectl. After installing Argo CD, since it doesn't include the Argo CD CLI, I installed the CLI using Chocolatey. I chose the port-forward method to access the Argo CD API server. By doing this, I can access the API server at localhost port 8080.

The second demo is to register my cluster. First, I list my clusters with the command 'kubectl config get-contexts -o name'. I can see 'minikube' in the list, which is what I want to register. To verify, I list the Argo CD clusters with the command 'argocd cluster list'.

In the next demo, I'm going to show how to connect Argo CD to a Git repo and how to create an Argo CD application, which is a configuration object. First, let's set the current namespace to Argo CD. I'll skip the execution because it's already done. We can create an Argo CD application via CLI or GUI. When the Git repo is a public repository, this command 'argocd app create guestbook --repo https://github.com/argoproj/argocd-example-apps.git --path guestbook --dest-server https://kubernetes.default.svc --dest-namespace default' will connect Argo CD to the Git repo and create the Argo CD application at once. When we create the application via GUI, we need a Git repo URL, and we're going to use 'https://kubernetes.default.svc' for the cluster URL, which means deploy to the same cluster where Argo CD is running.

The next step is to sync the application. First, get the application info with the command 'argocd app get guestbook' and sync it with 'argocd app sync guestbook'. This command retrieves the manifests from the repository and performs a kubectl apply of the manifests. Let's verify the result with 'argocd app list'; it will show the app's sync status and health.

Now I'm going to create drift intentionally. In the Git repo, the number of replicas is defined as 1, but let's make changes in the cluster without changing the codebase. With this command, 'kubectl scale deployment guestbook-ui --replicas=3 -n default', it is scaled up to 3 replicas. When I execute the command 'argocd app get guestbook', now we can see the application is out of sync. After we correct the drift, let's see the deployment history. As you can see, the number of replicas was scaled up to 3 then back down to 1.

The next demonstration is about rollback. I will make changes in my codebase, push it, then revert it. Let's increase the number of replicas again. After pushing the change, we sync the application. To see the number of replicas, execute the command 'kubectl get deployment guestbook-ui -n default'. Now let's revert the commit, then push and sync again. When we check the number of replicas, it scales back to 1 again.

In the last demonstration, I will make the application unhealthy intentionally. Let's replace the image address with the wrong one. Because the image doesn't exist, it won't deploy a container properly. I made the change, push, and sync in order. We can monitor pods with this command 'kubectl get pods -n default -w'. It shows it's having trouble pulling the image. Let's revert the change, push, and sync again. When we check the app status, it's all healthy now.

To summarize, this demonstrates the complete GitOps flow. We have Git as our single source of truth where we define the desired state of our applications. Argo CD continuously monitors the Git repository and automatically syncs changes to the Kubernetes cluster. When we make changes in Git, Argo CD detects them and applies them to the cluster. When there's drift - meaning someone makes manual changes to the cluster - Argo CD can detect this and either alert us or automatically correct it back to the Git state. This Git to Argo CD to Cluster flow ensures that our deployments are always consistent, auditable, and repeatable. That's the power of GitOps with Argo CD.